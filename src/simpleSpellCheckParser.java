/*
 * Copyright (c) 2025 - 2026 PCazzaniga (github.com)
 *
 *     simpleSpellCheckParser.java is part of SIMPLE.
 *
 *     SIMPLE is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     SIMPLE is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with SIMPLE.  If not, see <http://www.gnu.org/licenses/>.
 */

// Generated by ANTLR 4.13.2

import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.RuntimeMetaData;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.Vocabulary;
import org.antlr.v4.runtime.VocabularyImpl;
import org.antlr.v4.runtime.atn.ATN;
import org.antlr.v4.runtime.atn.ATNDeserializer;
import org.antlr.v4.runtime.atn.ParserATNSimulator;
import org.antlr.v4.runtime.atn.PredictionContextCache;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.tree.ParseTreeListener;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.List;

@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast", "CheckReturnValue", "this-escape"})
public class simpleSpellCheckParser extends Parser {
	static { RuntimeMetaData.checkVersion("4.13.2", RuntimeMetaData.VERSION); }

	protected static final DFA[] _decisionToDFA;
	protected static final PredictionContextCache _sharedContextCache =
		new PredictionContextCache();
	public static final int
		NAME=1, NUM=2, TEXT=3, COMMENT=4, TAB=5, NEWLINE=6, S=7, NEWTYPE=8, SCOPE_OPEN=9, 
		DEFINE=10, MAIN=11, RESULT=12, PARAMS=13, SEPAR=14, PARAMS_ONLY=15, COMMA=16, 
		SCOPE_CLOSE=17, IF=18, THEN=19, ELSEIF=20, ELSE=21, REPEAT=22, WHILE=23, 
		TIMES=24, RETURN=25, PREPARE=26, NAMED=27, VALUED=28, SET=29, TO=30, INSERT=31, 
		IN=32, REMOVE=33, SPLIT=34, MERGE=35, NUMBER=36, STRING=37, BOOL=38, EXP_OPEN=39, 
		EXP_CLOSE=40, SEQUENCE=41, LIST=42, KIT=43, POSITION=44, AT_FIELD=45, 
		OUTP=46, INP=47, COUNTER=48, SIZEOF=49, RANDOM=50, NULL=51, TXT_DELIM=52, 
		ESCAPER=53, DOT=54, SEQ_OPEN=55, SEQ_CLOSE=56, LST_DELIM=57, SEPAR_ALT=58, 
		KIT_OPEN=59, KIT_CLOSE=60, ADD=61, SUB=62, MULT=63, DIV=64, MODULUS=65, 
		AND=66, OR=67, NOT=68, GT=69, LT=70, EQ=71, CALL=72, ARGUMENTS=73, TYPE_PREFIX=74, 
		COMM_DELIM=75, TRUE=76, FALSE=77, UNKNOWN=78;
	public static final int
		RULE_file = 0, RULE_element = 1, RULE_mistake = 2;
	private static String[] makeRuleNames() {
		return new String[] {
			"file", "element", "mistake"
		};
	}
	public static final String[] ruleNames = makeRuleNames();

	private static String[] makeLiteralNames() {
		return new String[] {
			null, null, null, null, null, null, null, "' '", "'as a new type'", "':'", 
			"'Define a procedure with name'", "'Main'", "'that produces a'", "'using'", 
			"', '", "'that uses a'", "','", "';'", "'If'", "'then'", "'Else if'", 
			"'Else'", "'Repeat'", "'while'", "'times'", "'Return'", "'Prepare a'", 
			"'with name'", "'and value of'", "'Set'", "'to value of'", "'Insert'", 
			"'in'", "'Remove from'", "'Split'", "'Merge'", "'Number'", "'Text'", 
			"'Boolean'", "'('", "')'", "'Sequence of'", "'List of'", "'Kit of'", 
			"'at position'", "'@'", "'Output'", "'Input'", "'Counter'", "'size of'", 
			"'Random'", "'Nothing'", "'\"'", "'\\'", "'.'", "'['", "']'", "'|'", 
			"'; '", "'{'", "'}'", "'+'", "'-'", "'*'", "'/'", "'mod'", "'and'", "'or'", 
			"'not'", "'>'", "'<'", "'='", "'Execute procedure'", "'with'", "'#'", 
			"'%%'", "'True'", "'False'"
		};
	}
	private static final String[] _LITERAL_NAMES = makeLiteralNames();
	private static String[] makeSymbolicNames() {
		return new String[] {
			null, "NAME", "NUM", "TEXT", "COMMENT", "TAB", "NEWLINE", "S", "NEWTYPE", 
			"SCOPE_OPEN", "DEFINE", "MAIN", "RESULT", "PARAMS", "SEPAR", "PARAMS_ONLY", 
			"COMMA", "SCOPE_CLOSE", "IF", "THEN", "ELSEIF", "ELSE", "REPEAT", "WHILE", 
			"TIMES", "RETURN", "PREPARE", "NAMED", "VALUED", "SET", "TO", "INSERT", 
			"IN", "REMOVE", "SPLIT", "MERGE", "NUMBER", "STRING", "BOOL", "EXP_OPEN", 
			"EXP_CLOSE", "SEQUENCE", "LIST", "KIT", "POSITION", "AT_FIELD", "OUTP", 
			"INP", "COUNTER", "SIZEOF", "RANDOM", "NULL", "TXT_DELIM", "ESCAPER", 
			"DOT", "SEQ_OPEN", "SEQ_CLOSE", "LST_DELIM", "SEPAR_ALT", "KIT_OPEN", 
			"KIT_CLOSE", "ADD", "SUB", "MULT", "DIV", "MODULUS", "AND", "OR", "NOT", 
			"GT", "LT", "EQ", "CALL", "ARGUMENTS", "TYPE_PREFIX", "COMM_DELIM", "TRUE", 
			"FALSE", "UNKNOWN"
		};
	}
	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();
	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

	@Deprecated
	public static final String[] tokenNames;
	static {
		tokenNames = new String[_SYMBOLIC_NAMES.length];
		for (int i = 0; i < tokenNames.length; i++) {
			tokenNames[i] = VOCABULARY.getLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = VOCABULARY.getSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
		return tokenNames;
	}

	@Override
	public Vocabulary getVocabulary() {
		return VOCABULARY;
	}

	@Override
	public String getGrammarFileName() { return "simpleSpellCheck.g4"; }

	@Override
	public String[] getRuleNames() { return ruleNames; }

	@Override
	public String getSerializedATN() { return _serializedATN; }

	@Override
	public ATN getATN() { return _ATN; }

	public simpleSpellCheckParser(TokenStream input) {
		super(input);
		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
	}

	@SuppressWarnings("CheckReturnValue")
	public static class FileContext extends ParserRuleContext {
		public List<ElementContext> element() {
			return getRuleContexts(ElementContext.class);
		}
		public ElementContext element(int i) {
			return getRuleContext(ElementContext.class,i);
		}
		public List<MistakeContext> mistake() {
			return getRuleContexts(MistakeContext.class);
		}
		public MistakeContext mistake(int i) {
			return getRuleContext(MistakeContext.class,i);
		}
		public FileContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_file; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof simpleSpellCheckListener ) ((simpleSpellCheckListener)listener).enterFile(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof simpleSpellCheckListener ) ((simpleSpellCheckListener)listener).exitFile(this);
		}
	}

	public final FileContext file() throws RecognitionException {
		FileContext _localctx = new FileContext(_ctx, getState());
		enterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(8); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				setState(8);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case NAME:
				case NUM:
				case TEXT:
				case COMMENT:
				case TAB:
				case NEWLINE:
				case S:
				case NEWTYPE:
				case SCOPE_OPEN:
				case DEFINE:
				case MAIN:
				case RESULT:
				case PARAMS:
				case SEPAR:
				case PARAMS_ONLY:
				case COMMA:
				case SCOPE_CLOSE:
				case IF:
				case THEN:
				case ELSEIF:
				case ELSE:
				case REPEAT:
				case WHILE:
				case TIMES:
				case RETURN:
				case PREPARE:
				case NAMED:
				case VALUED:
				case SET:
				case TO:
				case INSERT:
				case IN:
				case REMOVE:
				case SPLIT:
				case MERGE:
				case NUMBER:
				case STRING:
				case BOOL:
				case EXP_OPEN:
				case EXP_CLOSE:
				case SEQUENCE:
				case LIST:
				case KIT:
				case POSITION:
				case AT_FIELD:
				case OUTP:
				case INP:
				case COUNTER:
				case SIZEOF:
				case RANDOM:
				case NULL:
				case DOT:
				case SEQ_OPEN:
				case SEQ_CLOSE:
				case LST_DELIM:
				case SEPAR_ALT:
				case KIT_OPEN:
				case KIT_CLOSE:
				case ADD:
				case SUB:
				case MULT:
				case DIV:
				case MODULUS:
				case AND:
				case OR:
				case NOT:
				case GT:
				case LT:
				case EQ:
				case CALL:
				case ARGUMENTS:
				case TYPE_PREFIX:
				case TRUE:
				case FALSE:
					{
					setState(6);
					element();
					}
					break;
				case UNKNOWN:
					{
					setState(7);
					mistake();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				setState(10); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & -13510798882111490L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 30719L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ElementContext extends ParserRuleContext {
		public TerminalNode NAME() { return getToken(simpleSpellCheckParser.NAME, 0); }
		public TerminalNode NUM() { return getToken(simpleSpellCheckParser.NUM, 0); }
		public TerminalNode TEXT() { return getToken(simpleSpellCheckParser.TEXT, 0); }
		public TerminalNode COMMENT() { return getToken(simpleSpellCheckParser.COMMENT, 0); }
		public TerminalNode TAB() { return getToken(simpleSpellCheckParser.TAB, 0); }
		public TerminalNode NEWLINE() { return getToken(simpleSpellCheckParser.NEWLINE, 0); }
		public TerminalNode S() { return getToken(simpleSpellCheckParser.S, 0); }
		public TerminalNode NEWTYPE() { return getToken(simpleSpellCheckParser.NEWTYPE, 0); }
		public TerminalNode SCOPE_OPEN() { return getToken(simpleSpellCheckParser.SCOPE_OPEN, 0); }
		public TerminalNode DEFINE() { return getToken(simpleSpellCheckParser.DEFINE, 0); }
		public TerminalNode MAIN() { return getToken(simpleSpellCheckParser.MAIN, 0); }
		public TerminalNode RESULT() { return getToken(simpleSpellCheckParser.RESULT, 0); }
		public TerminalNode PARAMS() { return getToken(simpleSpellCheckParser.PARAMS, 0); }
		public TerminalNode SEPAR() { return getToken(simpleSpellCheckParser.SEPAR, 0); }
		public TerminalNode PARAMS_ONLY() { return getToken(simpleSpellCheckParser.PARAMS_ONLY, 0); }
		public TerminalNode COMMA() { return getToken(simpleSpellCheckParser.COMMA, 0); }
		public TerminalNode SCOPE_CLOSE() { return getToken(simpleSpellCheckParser.SCOPE_CLOSE, 0); }
		public TerminalNode IF() { return getToken(simpleSpellCheckParser.IF, 0); }
		public TerminalNode THEN() { return getToken(simpleSpellCheckParser.THEN, 0); }
		public TerminalNode ELSEIF() { return getToken(simpleSpellCheckParser.ELSEIF, 0); }
		public TerminalNode ELSE() { return getToken(simpleSpellCheckParser.ELSE, 0); }
		public TerminalNode REPEAT() { return getToken(simpleSpellCheckParser.REPEAT, 0); }
		public TerminalNode WHILE() { return getToken(simpleSpellCheckParser.WHILE, 0); }
		public TerminalNode TIMES() { return getToken(simpleSpellCheckParser.TIMES, 0); }
		public TerminalNode RETURN() { return getToken(simpleSpellCheckParser.RETURN, 0); }
		public TerminalNode PREPARE() { return getToken(simpleSpellCheckParser.PREPARE, 0); }
		public TerminalNode NAMED() { return getToken(simpleSpellCheckParser.NAMED, 0); }
		public TerminalNode VALUED() { return getToken(simpleSpellCheckParser.VALUED, 0); }
		public TerminalNode SET() { return getToken(simpleSpellCheckParser.SET, 0); }
		public TerminalNode TO() { return getToken(simpleSpellCheckParser.TO, 0); }
		public TerminalNode INSERT() { return getToken(simpleSpellCheckParser.INSERT, 0); }
		public TerminalNode IN() { return getToken(simpleSpellCheckParser.IN, 0); }
		public TerminalNode REMOVE() { return getToken(simpleSpellCheckParser.REMOVE, 0); }
		public TerminalNode SPLIT() { return getToken(simpleSpellCheckParser.SPLIT, 0); }
		public TerminalNode MERGE() { return getToken(simpleSpellCheckParser.MERGE, 0); }
		public TerminalNode NUMBER() { return getToken(simpleSpellCheckParser.NUMBER, 0); }
		public TerminalNode STRING() { return getToken(simpleSpellCheckParser.STRING, 0); }
		public TerminalNode BOOL() { return getToken(simpleSpellCheckParser.BOOL, 0); }
		public TerminalNode EXP_OPEN() { return getToken(simpleSpellCheckParser.EXP_OPEN, 0); }
		public TerminalNode EXP_CLOSE() { return getToken(simpleSpellCheckParser.EXP_CLOSE, 0); }
		public TerminalNode SEQUENCE() { return getToken(simpleSpellCheckParser.SEQUENCE, 0); }
		public TerminalNode LIST() { return getToken(simpleSpellCheckParser.LIST, 0); }
		public TerminalNode KIT() { return getToken(simpleSpellCheckParser.KIT, 0); }
		public TerminalNode POSITION() { return getToken(simpleSpellCheckParser.POSITION, 0); }
		public TerminalNode AT_FIELD() { return getToken(simpleSpellCheckParser.AT_FIELD, 0); }
		public TerminalNode OUTP() { return getToken(simpleSpellCheckParser.OUTP, 0); }
		public TerminalNode INP() { return getToken(simpleSpellCheckParser.INP, 0); }
		public TerminalNode COUNTER() { return getToken(simpleSpellCheckParser.COUNTER, 0); }
		public TerminalNode SIZEOF() { return getToken(simpleSpellCheckParser.SIZEOF, 0); }
		public TerminalNode RANDOM() { return getToken(simpleSpellCheckParser.RANDOM, 0); }
		public TerminalNode NULL() { return getToken(simpleSpellCheckParser.NULL, 0); }
		public TerminalNode DOT() { return getToken(simpleSpellCheckParser.DOT, 0); }
		public TerminalNode SEQ_OPEN() { return getToken(simpleSpellCheckParser.SEQ_OPEN, 0); }
		public TerminalNode SEQ_CLOSE() { return getToken(simpleSpellCheckParser.SEQ_CLOSE, 0); }
		public TerminalNode LST_DELIM() { return getToken(simpleSpellCheckParser.LST_DELIM, 0); }
		public TerminalNode SEPAR_ALT() { return getToken(simpleSpellCheckParser.SEPAR_ALT, 0); }
		public TerminalNode KIT_OPEN() { return getToken(simpleSpellCheckParser.KIT_OPEN, 0); }
		public TerminalNode KIT_CLOSE() { return getToken(simpleSpellCheckParser.KIT_CLOSE, 0); }
		public TerminalNode ADD() { return getToken(simpleSpellCheckParser.ADD, 0); }
		public TerminalNode SUB() { return getToken(simpleSpellCheckParser.SUB, 0); }
		public TerminalNode MULT() { return getToken(simpleSpellCheckParser.MULT, 0); }
		public TerminalNode DIV() { return getToken(simpleSpellCheckParser.DIV, 0); }
		public TerminalNode MODULUS() { return getToken(simpleSpellCheckParser.MODULUS, 0); }
		public TerminalNode AND() { return getToken(simpleSpellCheckParser.AND, 0); }
		public TerminalNode OR() { return getToken(simpleSpellCheckParser.OR, 0); }
		public TerminalNode NOT() { return getToken(simpleSpellCheckParser.NOT, 0); }
		public TerminalNode GT() { return getToken(simpleSpellCheckParser.GT, 0); }
		public TerminalNode LT() { return getToken(simpleSpellCheckParser.LT, 0); }
		public TerminalNode EQ() { return getToken(simpleSpellCheckParser.EQ, 0); }
		public TerminalNode CALL() { return getToken(simpleSpellCheckParser.CALL, 0); }
		public TerminalNode ARGUMENTS() { return getToken(simpleSpellCheckParser.ARGUMENTS, 0); }
		public TerminalNode TYPE_PREFIX() { return getToken(simpleSpellCheckParser.TYPE_PREFIX, 0); }
		public TerminalNode TRUE() { return getToken(simpleSpellCheckParser.TRUE, 0); }
		public TerminalNode FALSE() { return getToken(simpleSpellCheckParser.FALSE, 0); }
		public ElementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_element; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof simpleSpellCheckListener ) ((simpleSpellCheckListener)listener).enterElement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof simpleSpellCheckListener ) ((simpleSpellCheckListener)listener).exitElement(this);
		}
	}

	public final ElementContext element() throws RecognitionException {
		ElementContext _localctx = new ElementContext(_ctx, getState());
		enterRule(_localctx, 2, RULE_element);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(12);
			_la = _input.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & -13510798882111490L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & 14335L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MistakeContext extends ParserRuleContext {
		public TerminalNode UNKNOWN() { return getToken(simpleSpellCheckParser.UNKNOWN, 0); }
		public MistakeContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_mistake; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof simpleSpellCheckListener ) ((simpleSpellCheckListener)listener).enterMistake(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof simpleSpellCheckListener ) ((simpleSpellCheckListener)listener).exitMistake(this);
		}
	}

	public final MistakeContext mistake() throws RecognitionException {
		MistakeContext _localctx = new MistakeContext(_ctx, getState());
		enterRule(_localctx, 4, RULE_mistake);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(14);
			match(UNKNOWN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static final String _serializedATN =
		"\u0004\u0001N\u0011\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001\u0002"+
		"\u0002\u0007\u0002\u0001\u0000\u0001\u0000\u0004\u0000\t\b\u0000\u000b"+
		"\u0000\f\u0000\n\u0001\u0001\u0001\u0001\u0001\u0002\u0001\u0002\u0001"+
		"\u0002\u0000\u0000\u0003\u0000\u0002\u0004\u0000\u0001\u0003\u0000\u0001"+
		"36JLM\u000f\u0000\b\u0001\u0000\u0000\u0000\u0002\f\u0001\u0000\u0000"+
		"\u0000\u0004\u000e\u0001\u0000\u0000\u0000\u0006\t\u0003\u0002\u0001\u0000"+
		"\u0007\t\u0003\u0004\u0002\u0000\b\u0006\u0001\u0000\u0000\u0000\b\u0007"+
		"\u0001\u0000\u0000\u0000\t\n\u0001\u0000\u0000\u0000\n\b\u0001\u0000\u0000"+
		"\u0000\n\u000b\u0001\u0000\u0000\u0000\u000b\u0001\u0001\u0000\u0000\u0000"+
		"\f\r\u0007\u0000\u0000\u0000\r\u0003\u0001\u0000\u0000\u0000\u000e\u000f"+
		"\u0005N\u0000\u0000\u000f\u0005\u0001\u0000\u0000\u0000\u0002\b\n";
	public static final ATN _ATN =
		new ATNDeserializer().deserialize(_serializedATN.toCharArray());
	static {
		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
		for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
		}
	}
}